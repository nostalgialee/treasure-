# -*- coding:utf-8 -*-
# @Time    : 2022/6/17 15:01
# @File    : basic_knowledge_of_operating_system.py
# Author: lee

"""
并发
        多个任务在同个cpu上交替执行


并行
        多个任务在多个cpu上同时执行



描述的是 --- 调用方调用的方式

判断标准：调用方是否用 callback、通知、状态 来获取返回结果

消息通信机制 --- 消息交换机制
    异步
            发布一个任务a，不等待任务a执行完毕，
              就执行我的其他任务
    同步
            发布一个任务a,等待获取这个任务a结束的结果之后
              才执行我的其他任务







描述的是 --- 接收方程序的状态
程序在等待调用结果（消息，返回值）的时候处于的状态

判断标准：接受方在请求发送之后是不是被挂起

处理事务时候的状态

阻塞
        调用者发出请求之后，线程因为某些原因（等待系统资源）被服务方挂起，
        当服务方获取到响应之后，唤醒挂起线程，并将response返回给调用方。




非阻塞
        调用者发送请求之后，在服务方得到结果之前都不会被挂起。
        直到得到响应之后才返回





ex:
老张用普通的水壶烧水，同时自己在火炉旁              等待水开 —— 同步阻塞式；
                 阻塞：没有执行其他事物被挂起     同步：等待等待结果

老张用普通的水壶烧上水后，去看电视，没看一会就去看一下水开了没有 —— 同步非阻塞；
                非阻塞：没有被挂起，        同步：等待查看结果

老张用响壶烧水，同时自己在火炉旁等待水开 —— 异步阻塞式；
    异步：返回机制         阻塞：没有执行其他任务，被挂起

老张用响壶烧水，然后去看电视，等水壶响后去取热水 —— 异步非阻塞
    异步         非阻塞


"""


"""
0.IO多路复用的作用？



"""


"""

1. select、poll、epoll模型的区别

先留着

"""



"""
2.简述进程，线程，协程的区别以及应用场景？

        程序执行三状态：
    
    就绪 <============>运行
    
         <-- 阻塞 <--


    进程：运行中的程序 每个进程存在唯一的pid
        1.单位级别：系统资源分配的最小单位
        2.进程中拥有独立的内存但愿，因此进程之间数据隔离
        
        
        3.进程的创建：
                系统初始化
                一个进程开启了一个子进程
                交互式请求
                一个批处理作业的初始化
        4.进程的退出：
                正常退出
                出错退出
                严重错误
                被其他进程杀死
        
        
    
    线程：进程中的单位 --- 轻量级进程 相较进程效率更高
        1.单位级别：计算机被调度的最小单位
        2.线程之间没有数据隔离，同一个进程内的线程共享同一部分数据
        2.使用场景：
            开启、关闭、切换进程需要时间，过多的进程会导致电脑崩溃
        
    
    
    协程：
        
"""






"""
3.什么时GIL锁
    多线程本可以利用多核，但是CPython解释器中存在 GIL--- 全局解释器锁
    多线程不可以访问多核心
    JPython 无 GIL 锁
    
"""





"""
4.python中如何使用进程池和线程池

from concurrent.futures import ThreadPoolExecutor

def func():
    pass

def call_back(back):
    pass

with ThreadPoolExecutor(3) as tpool:
    f1 = tpool.submit(func)
    f1.add_done_callback(call_back)

"""









"""
5.threading.local的作用
    为每个线程开辟一个独立的空降，使得线程
    对自己的空间中的数据进行操作（数据隔离）
    
"""





"""
6.进程之间如何进行通信？

    1.共享内存信号
        通过mmap模块实现

    队列
    管道
    网络
    文件

"""





"""
7.什么是并发和并行
并发：多个任务在一个cpu上被轮流执行 (时间段)
        指应用能够交替执行不同的任务,
        其实并发有点类似于多线程的原理,
        多线程并非是同时执行多个任务,
        如果你开两个线程执行,
        就是在你几乎不可能察觉到的速度不断去切换这两个任务,
        已达到"同时执行效果",
        其实并不是的,只是计算机的速度太快,我们无法察觉到而已.


并行：多个任务在多个cpu上同时执行 (时间点)


"""








"""
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

8.解释什么是异步非阻塞

    调用方的调用方式 -- 消息交换的机制
    
        同步：发布一个调用，在没有得到消息之后，调用不return
        异步：发布一个调用，无需等待调用返回的结果，调用直接return 
            怎么获得结果 --- 通过状态、通知来通知调用者，或者回调函数


    程序在等待调用返回是的状态
    
        阻塞：调用方发出一个请求之后，线程因为某些原因（等待系统资源）
        被服务方挂起，函数只有在得到结果之后才会返回。

        非阻塞：调用方发出一个请求之后，该函数不会阻塞当前线程，而会立刻返回。
        

"""







"""
9.生产者消费者模型的应用场景

生产者只有在仓库未满的时候进行成产，仓库满了就不需要生产
消费者只有在仓库非空的时候进行消费，仓库为空的话，消费者进程被堵塞


处理数据比较耗时，线程独占，生产数据不需要即时的反馈

实际例子：
    比如说写入日志，将多线程产生的日志放在队列中，然后写入。

"""








"""
10.守护线程，守护进程是什么
    守护进程 
        1.守护对象：守护主进程
        2.实质：子进程
        3.结束时间：主进程代码执行完毕后，守护进程挂掉
        4.流程：
                1.主进程代码执行完毕后，守护进程挂掉
                2.主进程等待所有非守护进程的子进程结束后，回收资源并结束
    
    守护线程
        1.守护对象：非守护线程
        2.实质：子线程
        3.结束时间：在所有的子线结束之后，主线程结束。
            意味着主进程结束，守护进程被主进程回收
    
    
"""





"""
11.简述多进程开发中join和deamon的区别
    
    join() 阻塞主(线)进程,等到子进程执行完毕之后，继续执行主进程余下代码
    
    daemon() # 设置守护进(线)程

"""





"""
12.GIL锁对python性能的影响

影响线程的执行效率，换言之，python是单线程语言
同一时间，多个线程不能访问多核 python解释器只能运行一个线程的代码

    解决：
        多进程取代多线程
        更换解释器

"""




"""
13.使用yield实现一个协程


def genertaion1():
    i = 0
    while 1:
        n = yield i
        return n


def genertaion2():
    while 1:
        res = yield from genertaion1()
        print('res:', res)


g1 = genertaion1()
g2 = genertaion2()
g2.send(None)
for i in range(12):
    g2.send(i)


"""







"""
14.使用async语法实现一个协程

#### 不会

"""








"""
15.简述线程死锁是怎么造成的。如何避免？

    系统资源的竞争
    进程运行推进顺序不当


    1.同一线程多次 acquire, 导致死锁
        RLock 解决
        
    2.科学家吃面问题 多个进程加了多个锁
        



"""






"""
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
16.什么是asyncio

    asyncio是并发的一种方式，是一个协程相关的库。也叫异步IO

"""






"""
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
17.什么是gevent

    gevent是一个pythn网络框架，它为各种并发和网络相关的任务提供了整洁的API
    
"""





"""
18.什么是LVS

"""





"""
19.
"""






"""
20.
"""







"""
21.
"""









"""
22.
"""







"""
23.
"""







"""
24.
"""






"""
25.
"""








"""
26.
"""







"""
27.
"""






"""
28.
"""






"""
29.
"""








"""
30.
"""





"""
31.
"""
