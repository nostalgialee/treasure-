
1 简述解释型和编译型编程语言
    解释型语言
    编写的程序不需要编译，执行时，专门有一个解释器能够将VB语言翻译成机器语言
    这样解释型语言每执行一次就要翻译一次。
    
    编译型语言
    程序执行之前，需要一个专门的编译过程，
    通过编译系统，把源高级程序编译成为机器语言文件
    运行时不需要翻译，所以编译型语言的程序执行效率高。



2.python解释器种类以及特点
    CPython
    c语言开发的 使用最广的解释器
    
    IPython
    基于cpython之上的一个交互式计时器，交互方式增强，功能和cpython一样
    
    PyPy
    目标是执行效率 采用JIT技术 对python代码进行动态编译，提高执行效率
    
    JPython
    运行在Java上的解释器 直接把python代码编译成Java字节码执行
    
    IronPython
    运行在微软 .NET 平台上的解释器，把python编译成. NET 的字节码



3.请列出至少5个PEP8规范PEP8规范
        每个缩进级别使用4个空格

        每行代码的最大长度限制为79个字符

        若是导入多个库函数，应该分开依次导入
         a、标准库导入 b、相关的第三方库导入 c、本地应用程序的库导入

        代码更改时，相应的注释也要随之更改

        在表达式中避免无关的空格
        
            在括号或者大括号内
            在尾随逗号和后面的右括号之间
            在逗号，分号或者冒号前面
            函数名的与后面的参数的括号之间
        
        命名要规范，通俗易懂
        
        
        
4.ascii、Unicode、utf-8、gbk的区别
        ascii
        美国用的标准信息交换码，所有的字母的大小写，各种符号用二进制来表示，
        共有256中，加入些拉丁文等字符，1字节代表一个字符
        
        Unicode是万国码，两个字节表示一个字符，最多可以表示2^16个字符，特点：速度快，但浪费空间
        
        utf-8 为了改变Unicode的这种缺点，
        一个字节表示一个英文字符
        三个字节表示一个中文字符
        节省空间，速度慢
        
        gbk 是中文的字符编码，用2个字节代表一个字符
        

5.字节码与机器码的区别
        机器码：CPU可以直接读取运行的机器指令，运行速度最快，但是晦涩难懂
        字节码：一种中间状态（中间码）的二进制文件，需要直译器转译后成为机器码
        
        
6.列举你所了解的所有Python2和Python3的区别
        1 p2中没有nonlocal关键字，修改临时变量只能将其变为可变数据类型，b=[a]
        2 p2: print'1' ----  p3 print('1')
        3 p3中加入Unicode字符串，使用编码存储字符串，例如可以使用utf-8输入中文
        4 Python3去掉long类型，新增了bytes。
        5 Python 3整数之间做除法可以得到浮点数的结果，不需要进行数据格式转换1/2=0.5 
            Python 2整数int间除法结果为把运算结果去尾的整数1/2=0，3/2.0=1.5
        6 Python3 中 range()，Python2 中 xrange()。
        7 python2中的不等于号可以是!=或者<>，python3只能是!=
        8 python2中raw_input()用来输入字符串，而python3中使用input()来输入字符串
        9.py2有long类型，py3 没有long类型，只有int类型，包含了long类型
        

7.python2与python3编码的区别
        py2的字符串有两种类型：unicode类型和str类型
            Unicode即为Unicode编码，str类型指的是除了Unicode以外所有的编码，
            包括ascii编码、utf8编码、gbk编码、cp936编码等
        
        
        py3的字符串有两种类型：bytes类型和str类型
            str类型即为Unicode编码, bytes类型指的是除了Unicode以为所有的编码
            包括ascii编码、utf8编码、gbk编码、cp936编码等
            

8.py2项目如何迁移成py3
        先备份原文件，然后使用python3自带工具2to3.py将py2文件转换位py3文件
        手动将不兼容的代码改写成兼容py3的代码
        
        
        
9.xrange和range的区别
xrange和range用法相同，但是xrange是一个生成器，range结果是一个列表。xrange做循环的时候性能比range好。

        
        
二、常见内容        
10.is和==的区别
is比较的是两个对象的id是否相同,内存地址是否相同
==比较的是两个对象的值是否相同



11.如何实现字符串的反转？如：name=felix，反转成name=xilef
    1.
        name = name[::-1]
    2.
        name = name.split('')
        name.reverse()
        name = ''.join(name)
    3.
        from functools import reduce
        name=reduce(lambda x, y: y+x, name)
        

12.文件操作时，xreadlines和readlines的区别
        readlines: 返回的是一个列表
        xreadlines：返回的是一个生成器
        

13.请列举布尔值位False的常见值
    [], None, '', 0 {}, tuple(), set()


*************字典这里要好好看看
14.列举字符串、列表、元组、字典每个常用的5个方法
    字符串
        strip()
        split()
        startwith()
        replace()
        find() # 查找字符串，存在返回第一个索引，不存在返回-1
    
    列表
        count()
        append()
        extend()
        pop()    删除一个对象，默认最后一个
        remove() 删除指定的第一个匹配项
        insert() 插入对象
        index()
        
    元祖
        count() ->统计在元组中出现的个数
        index() ->获取索引
    
    字段
        keys() ->获取所有的键
        pop() ->删除指定的键的键值对
        popitem() ->随机删除一个键值对 ******
        update() ->更新字典，参数为一个字典，如果键已存在，则更改，不存在则添加
        setdefault() ->如果键存在则，返回该键对应的值，如果不存在，设置该键为设置的默认值，然后返回该键对应的值
        get() ->返回键对应的值
        fromkeys() ->创建字典，第一个参数为可迭代对象，每个值变成字典的键，第二个参数为每个键的默认值


15 什么是反射 --- 基于字符串的事件驱动
    通过字符串的形式，导入模块
    通过字符串的形式，在模块中循寻找指定函数
    利用字符串的形式，在对象中操作成员（查找，获取，删除，添加）成员
    应用场景：我们需要动态的输入一个模块名字的时候
    hasattr, getattr, delattr, setattr
    
    delattr 函数用于删除属性。delattr(x, 'foobar') 相等于 del x.foobar
    
    setattr: 创建一个新的属性、设置属性值
    
    
    class A:
        name = 'xxx'
    
    a = A()
    setattr(a, 'age', 20)
    if hasattr(a, 'name':
        delattr(a, 'name')
    
    
    
16.简叙深浅拷贝
    浅拷贝：对于另一个变量的内存地址进行拷贝，两个变量指向同一块内存地址
        共用一个值
        这两个变量的内存地址一样
        对其中一个变量的值改变，另外一个变量的值也会改变
        对于可变数据类型，只拷贝第一层引用，即第一层内存地址变化，内层内存地址不变
    
    深拷贝：
        可变数据类型：只拷贝引用，即内存地址变化
        不可变数据类型：深拷贝无论所少层，都进行拷贝，即内存地址全部发生变化

        深拷贝的特点：
        两个变量的内存地址不同
        两个变量各有自己的值，且互不影响
        对其任意一个变量的值的改变不会影响另外一个

17.python的垃圾回收机制
    引用计数（主要） --- 不能解决循环引用的问题
        原理：
            每个对象维护一个 ob_ref 字段，用来记录当前对象被引用的次数
        当新的引用指向对象的时候 ob_ref +=1, 引用失效，ob_ref-=1, 引用计数为0
        的时候，对象被回收，空间被释放
        缺点：
            需要占用额外空间
            不能解决循环引用的问题
            sys.getrefcount(c) # 获取引用计数
            # 注意调用getrefcount()函数会临时增加一次引用计数
            得到的结果比预期的多一次。
        
        导致引用计数 +1 的情况
        
        对象被创建，例如 a=23
        对象被引用，例如 b=a
        对象被作为参数，传入到一个函数中，例如func(a)
        对象作为一个元素，存储在容器中，例如list1=[a,a]
        
        导致引用计数-1 的情况
        
        对象的别名被显式销毁，例如del a
        对象的别名被赋予新的对象，例如a=24
        一个对象离开它的作用域，例如 f 函数执行完毕时，func函数中的局部变量（全局变量不会）
        对象所在的容器被销毁，或从容器中删除对象
    
        循环引用导致内存泄露
        def f2():
            '''循环引用'''
            while True:
                c1=A()
                c2=A()
                c1.t=c2
                c2.t=c1
                del c1
                del c2
    
        创建了两个对象之后，引用计数分别为1，增加属性后引用计数为2
        del 之后，引用计数不为0，导致对象不会销毁，回收器不会回收，造成内存泄露
    
    
    分代回收 （辅助）
        分代回收是一种空间换时间的操作方式，python根据内存将对象的存活时间划为不同
        的集合，
        每个集合为一个代，Python 将内存分为了 3“代”，
        分别为年轻代（第 0 代）、
        中年代（第 1 代）、
        老年代（第 2 代），
        他们对应的是 3 个链表，
        它们的垃圾收集频率与对象的存活时间的增大而减小。

        新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，
        Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，
        而那些不会回收的对象就会被移到中年代去，
        依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。
    

    
    标记清除 （辅助）
        标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。
        它分为两个阶段：第一阶段是标记阶段，GC 会把所有的『活动对象』打上标记，
        第二阶段是把那些没有标记的对象『非活动对象』进行回收。
        那么 GC 又是如何判断哪些是活动对象哪些是非活动对象的呢？


        对象之间通过引用（指针）连在一起，构成一个有向图，
        对象构成这个有向图的节点，而引用关系构成这个有向图的边。
        从根对象（root object）出发，沿着有向边遍历对象，
        可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。
        根对象就是全局变量、调用栈、寄存器。
        mark-sweepg 在上图中，我们把小黑圈视为全局变量，
        也就是把它作为 root object，从小黑圈出发，对象 1 可直达，那么它将被标记，
        对象 2、3 可间接到达也会被标记，而 4 和 5 不可达，
        那么 1、2、3 就是活动对象，4 和 5 是非活动对象会被 GC 回收。

        标记清除算法作为 Python 的辅助垃圾收集技术主要处理的是一些容器对象，
        比如 list、dict、tuple，instance 等，因为对于字符串、数值对象是不可能造成循环引用问题。
        Python 使用一个双向链表将这些容器对象组织起来。
        不过，这种简单粗暴的标记清除算法也有明显的缺点：
        清除非活动的对象前它必须顺序扫描整个堆内存，
        哪怕只剩下小部分活动对象也要扫描所有对象。
        
        

    垃圾回收详解：
    https://testerhome.com/topics/16556

************************************不会的

18.求下面代码的结果
    v=dict.fromkeys(['k1','k2'],[])
    v['k1'].append(666)
    print(v)
    v['k1']=777
    print(v)

    romkeys的用法：
    用于创建并返回一个新的字典。
    两个参数：第一个是字典的键，第二个（可选）是传入键的值，默认为None。键分别为第二个参数
    fromkeys 只负责创建字典，不负责保存字典
    第二个参数若是容器型参数，就是同一块地址，否则不是

**************************补充一下
20.如何实现['1','2','3']变成[1,2,3]
    l = ['1','2','3']
    l = list(map(lambda i:int(i), l))
    或者 
    l = [int(i) for i in l]

21.比较：a=[1,2,3]和b=[(1),(2),(3)]以及c=[(1,),(2,),(3,)]的区别



22.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100]?
    l = [i**2 for i in range(1,11)]


23.常用字符串格式化有哪几种
    print('%s' % '你好')
    print('{0}{1}{2}'.format('1','2','3'))
    print('hello {first} and {second}'.format(first='friend',second='another friend'))
    
    
24.什么是断言(assert)?应用场景
    assert 是一个检查条件， == True 则pass，== False, 则会抛出AssertError异常， 包含错误信息
    
    
    应用场景：
        防御型编程
        运行时检查程序逻辑
        检查约定
        程序常量
        检查文档
    


25.有两个字符串列表a和b，每个字符串是由逗号隔开的一些字符
    a=[
        'a,1',
        'b,3,22',
        'c,3,4',
    ]
    b=[
        'a,2',
        'b,1',
        'd,5',
    ]
    # 按照a，b中每个字符串的第一个值，合并成c如下：
    c=[
        'a,1,2',
        'b,3,22,1',
        'c,3,4',
        'd,5'
    ]


26.有一个多层嵌套的列表A=[1,2,3,[4,1,['j1',1,[1,2,3,'aa']]]],请写一段代码将A中的元素全部打印出来
    递归
    
27.a=range(10),则a[::-3]的值是？
    [9,6,3,0] 或者 range(9,-1,-3)


28.将下面列表中的元素根据位数合并成字典：
lst = [1,2,4,8,16,32,64,128,256,512,1024,32769,65536,4294967296]



*************************************************************************
29.用尽量简洁的方法将二维数组合并成一维数组
        lst = [[1,2,3],[4,5,6],[7,8,9]]
        res = []
        for i in lst:
            res.extend(i)



************************************************************************* 一眼就不太会的，没考虑到绝对值 和 sorted
30.将列表按照下列规则排序
正数在前，负数在后
正数从小到大
负数从大到小
       ls = sorted(lis, key = lambda x:(x<0, abs(x),))


***************************************解决完算法
31.解决哈希冲突的算法有哪几种？分别有什么特点？



********************************************
32.简述python字符串的驻留机制

        相同的对象的引用指向同一块内存地址 ---- python的字符串驻留机制
        但是！！！
        python的引用计数机制，并不是对所有的数字，字符串，他只对“  [0-9] [a-z] [A-Z]和"_"(下划线)  ”有效，
        当字符串中由其他字符比如“！ @ # ￥ % -”时字符驻留机制是不起作用的。



！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
# 出现问题的点
copy.copy()

只能拷贝一层。根据类型有关。如果是列表(可变类型)，深拷贝。
如果是元组(不可变)浅拷贝如果里面还有嵌套的对象，浅拷贝

33.有如下代码：求 abcd 的值

        import copy
        a=[1,2,3,[4,5],6]
        b=a
        c=copy.copy(a)
        d=copy.deepcopy(a)
        b.append(10)
        c[3].append(11)
        d[3].append(12)
        
        所以 使用 copy.copy() 方法的可变数据结构，只有最外层被拷贝，里层不拷贝

       a = [1,2,3,[4,5,11],6,10]
       b = [1,2,3,[4,5,11],6,10]
       c = [1,2,3,[4,5,11],6]
       d = [1,2,3,[4,5,12],6]




!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
对于 sorted 不熟练还是有点问题
34.对字典d={'a':30,'g':17,'b':25,'c':18,'d':50,'e':36,'f':57,'h':25}按照value字段进行排序

        dic = sorted(d.items(), key=lambda x:x[1])




！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
压根没想到这个方法
35.找出两个列表中相同的元素和不同的元素
        list1=[1,2,3,5,8,7,11,10]
        list2=[5,15,25,10]

        diff = [i for i in list1+ if i not in list2]
        same = [i for i in list1 + list2 if i not in diff]









# 需要弥补的地方 - 
    迭代器 生成器 装饰器，协程等
    map() reduce()  sorted()等函数
    
    进程相关需要好好复习
    数据库
    
    
    



        
        
        
        
        
        
        
        
        
        
        
        
        
